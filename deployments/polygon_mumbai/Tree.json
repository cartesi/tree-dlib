{
  "address": "0xaE6Ab17f71736E18A9b49307E3cF7B4bF711fbFC",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_parent",
          "type": "uint256"
        }
      ],
      "name": "VertexInserted",
      "type": "event"
    }
  ],
  "transactionHash": "0xc0f8244285c7de0ed62d745db3995fc1efe32e7f9ff42598a1be253eeeae977d",
  "receipt": {
    "to": null,
    "from": "0x18930e8a66a1DbE21D00581216789AAB7460Afd0",
    "contractAddress": "0xaE6Ab17f71736E18A9b49307E3cF7B4bF711fbFC",
    "transactionIndex": 0,
    "gasUsed": "597844",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000030000000000000000000000020000000000000000000008000000000000000000000000000000000000000000000000000000000800000000000000000000100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000004000000000000000000001000000000000000000000000000000100000001000000000000000000000000000000000000000000000000000000000024000100000",
    "blockHash": "0x070d0c8baaaec52cb8c80f87fd984f8e2e215bdec11e0cf2b52267678ad77b48",
    "transactionHash": "0xc0f8244285c7de0ed62d745db3995fc1efe32e7f9ff42598a1be253eeeae977d",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 27265737,
        "transactionHash": "0xc0f8244285c7de0ed62d745db3995fc1efe32e7f9ff42598a1be253eeeae977d",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x00000000000000000000000018930e8a66a1dbe21d00581216789aab7460afd0",
          "0x000000000000000000000000f903ba9e006193c1527bfbe65fe2123704ea3f99"
        ],
        "data": "0x000000000000000000000000000000000000000000000000005934e8f04bf4b400000000000000000000000000000000000000000000000051bd159673c46e930000000000000000000000000000000000000000000004f421798c4a3d2f845e0000000000000000000000000000000000000000000000005163e0ad837879df0000000000000000000000000000000000000000000004f421d2c1332d7b7912",
        "logIndex": 0,
        "blockHash": "0x070d0c8baaaec52cb8c80f87fd984f8e2e215bdec11e0cf2b52267678ad77b48"
      }
    ],
    "blockNumber": 27265737,
    "cumulativeGasUsed": "597844",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 4,
  "solcInputHash": "4aef673ac42219926821680e316f7430",
  "metadata": "{\"compiler\":{\"version\":\"0.8.15+commit.e14f2714\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_parent\",\"type\":\"uint256\"}],\"name\":\"VertexInserted\",\"type\":\"event\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getAncestor(Tree.TreeCtx storage,uint256,uint256)\":{\"params\":{\"_ancestorOffset\":\"the offset of the ancestor in ancestor map\",\"_tree\":\"pointer to the tree storage\",\"_vertex\":\"the index of the vertex in the vertices map (tree)\"},\"returns\":{\"_0\":\"index of ancestor vertex in the tree\"}},\"getAncestorAtDepth(Tree.TreeCtx storage,uint256,uint256)\":{\"params\":{\"_depth\":\"the depth of the ancestor\",\"_tree\":\"pointer to the tree storage\",\"_vertex\":\"the index of the vertex in the vertices map (tree)\"},\"returns\":{\"_0\":\"index of ancestor at depth of _vertex\"}},\"getDeepest(Tree.TreeCtx storage)\":{\"params\":{\"_tree\":\"pointer to the tree storage\"},\"returns\":{\"_0\":\"index number and depth of the deepest vertex\"}},\"getDepth(Tree.TreeCtx storage,uint256)\":{\"params\":{\"_tree\":\"pointer to the tree storage\",\"_vertex\":\"the index of the vertex in the vertices map (tree)\"}},\"getTreeSize(Tree.TreeCtx storage)\":{\"params\":{\"_tree\":\"pointer to the tree storage\"}},\"getVertex(Tree.TreeCtx storage,uint256)\":{\"params\":{\"_tree\":\"pointer to the tree storage\",\"_vertex\":\"the index of the vertex in the vertices map (tree)\"}},\"insertVertex(Tree.TreeCtx storage,uint256)\":{\"details\":\"the tree can hold up to UINT32_MAX vertices, if the insertVertex is called when tree is full, the transaction will be reverted\",\"params\":{\"_parent\":\"the index of parent vertex in the vertices map (tree)\",\"_tree\":\"pointer to the tree storage\"},\"returns\":{\"_0\":\"index of the inserted vertex\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getAncestor(Tree.TreeCtx storage,uint256,uint256)\":{\"notice\":\"Get an ancestor of a vertex in the tree with a certain ancestor offset\"},\"getAncestorAtDepth(Tree.TreeCtx storage,uint256,uint256)\":{\"notice\":\"Search an ancestor of a vertex in the tree at a certain depth\"},\"getDeepest(Tree.TreeCtx storage)\":{\"notice\":\"Get current tree size\"},\"getDepth(Tree.TreeCtx storage,uint256)\":{\"notice\":\"Get depth of vertex\"},\"getTreeSize(Tree.TreeCtx storage)\":{\"notice\":\"Get current tree size\"},\"getVertex(Tree.TreeCtx storage,uint256)\":{\"notice\":\"Get vertex from the tree\"},\"insertVertex(Tree.TreeCtx storage,uint256)\":{\"notice\":\"Insert a vertex to the tree\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Tree.sol\":\"Tree\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/Tree.sol\":{\"content\":\"// Copyright 2022 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Tree Library\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Tree {\\n    // The tree can store up to UINT32_MAX vertices, the type uses uint256 for gas optimization purpose.\\n    // It's the library caller's responsibility to check the input arguments are within the proper range\\n    uint256 constant UINT32_MAX = 2**32 - 1;\\n    // count of trailing ones for [0:256)\\n    // each number takes one byte\\n    bytes constant trailing1table =\\n        hex\\\"00010002000100030001000200010004000100020001000300010002000100050001000200010003000100020001000400010002000100030001000200010006000100020001000300010002000100040001000200010003000100020001000500010002000100030001000200010004000100020001000300010002000100070001000200010003000100020001000400010002000100030001000200010005000100020001000300010002000100040001000200010003000100020001000600010002000100030001000200010004000100020001000300010002000100050001000200010003000100020001000400010002000100030001000200010008\\\";\\n\\n    struct TreeCtx {\\n        uint32 deepestVertex;\\n        uint32 deepestDepth;\\n        uint32 verticesLength;\\n        mapping(uint256 => Vertex) vertices;\\n    }\\n\\n    struct Vertex {\\n        uint32 depth; // depth of the vertex in the tree\\n        uint32 ancestorsLength;\\n        // Each uint256 value stores 8 ancestors, each takes a uint32 slot,\\n        // the key used to access the value should be preprocessed,\\n        // 0 => uint32[7],uint32[6],uint32[5],uint32[4],uint32[3],uint32[2],uint32[1],uint32[0]\\n        // 1 => uint32[15],uint32[14],uint32[13],uint32[12],uint32[11],uint32[10],uint32[9],uint32[8]\\n        // A vertex can have up to 32 ancestors\\n        mapping(uint256 => uint256) ancestors; // pointers to ancestors' indices in the vertices map (tree)\\n    }\\n\\n    event VertexInserted(uint256 _parent);\\n\\n    /// @notice Insert a vertex to the tree\\n    /// @param _tree pointer to the tree storage\\n    /// @param _parent the index of parent vertex in the vertices map (tree)\\n    /// @return index of the inserted vertex\\n    /// @dev the tree can hold up to UINT32_MAX vertices, if the insertVertex is called when tree is full, the transaction will be reverted\\n    function insertVertex(TreeCtx storage _tree, uint256 _parent)\\n        external\\n        returns (uint256)\\n    {\\n        uint256 treeSize = _tree.verticesLength;\\n\\n        _tree.verticesLength++;\\n        Vertex storage v = _tree.vertices[treeSize];\\n\\n        if (treeSize == 0) {\\n            // insert the very first vertex into the tree\\n            // v is initialized with zeros already\\n        } else {\\n            // insert vertex to the tree attaching to another vertex\\n            require(_parent < treeSize, \\\"parent index exceeds tree size\\\");\\n\\n            uint256 parentDepth = _tree.vertices[_parent].depth;\\n\\n            // construct the ancestors map in batch\\n            batchSetAncestors(v, parentDepth);\\n        }\\n\\n        uint256 depth = v.depth;\\n        if (depth > _tree.deepestDepth) {\\n            _tree.deepestDepth = uint32(depth);\\n            _tree.deepestVertex = uint32(treeSize);\\n        }\\n\\n        emit VertexInserted(_parent);\\n\\n        return treeSize;\\n    }\\n\\n    /// @notice Set ancestors in batches, each of which has up to 8 ancestors\\n    /// @param _v pointer to the vertex storage\\n    /// @param _parentDepth the parent depth\\n    function batchSetAncestors(Vertex storage _v, uint256 _parentDepth)\\n        private\\n    {\\n        // calculate all ancestors' depths of the new vertex\\n        uint256[] memory requiredDepths = getRequiredDepths(_parentDepth + 1);\\n        uint256 batchPointer; // point to the beginning of a batch\\n\\n        while (batchPointer < requiredDepths.length) {\\n            uint256 ancestorsBatch; // stores up to 8 ancestors\\n            uint256 offset; // 0~8\\n            while (\\n                offset < 8 && batchPointer + offset < requiredDepths.length\\n            ) {\\n                ancestorsBatch =\\n                    ancestorsBatch |\\n                    (requiredDepths[batchPointer + offset] << (offset * 32));\\n\\n                ++offset;\\n            }\\n            _v.ancestors[batchPointer / 8] = ancestorsBatch;\\n\\n            batchPointer += offset;\\n        }\\n\\n        _v.depth = uint32(_parentDepth + 1);\\n        _v.ancestorsLength = uint32(requiredDepths.length);\\n    }\\n\\n    /// @notice Get an ancestor of a vertex in the tree with a certain ancestor offset\\n    /// @param _tree pointer to the tree storage\\n    /// @param _vertex the index of the vertex in the vertices map (tree)\\n    /// @param _ancestorOffset the offset of the ancestor in ancestor map\\n    /// @return index of ancestor vertex in the tree\\n    function getAncestor(\\n        TreeCtx storage _tree,\\n        uint256 _vertex,\\n        uint256 _ancestorOffset\\n    ) public view returns (uint256) {\\n        require(\\n            _vertex < _tree.verticesLength,\\n            \\\"vertex index exceeds tree size\\\"\\n        );\\n\\n        Vertex storage v = _tree.vertices[_vertex];\\n\\n        uint256 key = _ancestorOffset / 8;\\n        uint256 offset = _ancestorOffset % 8;\\n        uint256 ancestor = (v.ancestors[key] >> (offset * 32)) & 0xffffffff;\\n\\n        return ancestor;\\n    }\\n\\n    /// @notice Search an ancestor of a vertex in the tree at a certain depth\\n    /// @param _tree pointer to the tree storage\\n    /// @param _vertex the index of the vertex in the vertices map (tree)\\n    /// @param _depth the depth of the ancestor\\n    /// @return index of ancestor at depth of _vertex\\n    function getAncestorAtDepth(\\n        TreeCtx storage _tree,\\n        uint256 _vertex,\\n        uint256 _depth\\n    ) external view returns (uint256) {\\n        require(\\n            _vertex < _tree.verticesLength,\\n            \\\"vertex index exceeds tree size\\\"\\n        );\\n        require(\\n            _depth <= _tree.vertices[_vertex].depth,\\n            \\\"search depth > vertex depth\\\"\\n        );\\n\\n        uint256 vertex = _vertex;\\n\\n        while (_depth != _tree.vertices[vertex].depth) {\\n            Vertex storage v = _tree.vertices[vertex];\\n            uint256 ancestorsLength = v.ancestorsLength;\\n            // start searching from the oldest ancestor (smallest depth)\\n            // example: search ancestor at depth d(20, b'0001 0100) from vertex v at depth (176, b'1011 0000)\\n            //    b'1011 0000 -> b'1010 0000 -> b'1000 0000\\n            // -> b'0100 0000 -> b'0010 0000 -> b'0001 1000\\n            // -> b'0001 0100\\n\\n            // given that ancestorsOffset is unsigned, when -1 at 0, it'll underflow and become UINT32_MAX\\n            // so the continue condition has to be ancestorsOffset < ancestorsLength,\\n            // can't be ancestorsOffset >= 0\\n            uint256 temp_v = vertex;\\n            for (\\n                uint256 ancestorsOffset = ancestorsLength - 1;\\n                ancestorsOffset < ancestorsLength;\\n\\n            ) {\\n                vertex = getAncestor(_tree, temp_v, ancestorsOffset);\\n\\n                // stop at the ancestor who's closest to the target depth\\n                if (_tree.vertices[vertex].depth >= _depth) {\\n                    break;\\n                }\\n\\n                unchecked {\\n                    --ancestorsOffset;\\n                }\\n            }\\n        }\\n\\n        return vertex;\\n    }\\n\\n    /// @notice Get depth of vertex\\n    /// @param _tree pointer to the tree storage\\n    /// @param _vertex the index of the vertex in the vertices map (tree)\\n    function getDepth(TreeCtx storage _tree, uint256 _vertex)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return getVertex(_tree, _vertex).depth;\\n    }\\n\\n    /// @notice Get vertex from the tree\\n    /// @param _tree pointer to the tree storage\\n    /// @param _vertex the index of the vertex in the vertices map (tree)\\n    function getVertex(TreeCtx storage _tree, uint256 _vertex)\\n        public\\n        view\\n        returns (Vertex storage)\\n    {\\n        require(\\n            _vertex < _tree.verticesLength,\\n            \\\"vertex index exceeds tree size\\\"\\n        );\\n\\n        return _tree.vertices[_vertex];\\n    }\\n\\n    /// @notice Get current tree size\\n    /// @param _tree pointer to the tree storage\\n    function getTreeSize(TreeCtx storage _tree)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return _tree.verticesLength;\\n    }\\n\\n    /// @notice Get current tree size\\n    /// @param _tree pointer to the tree storage\\n    /// @return index number and depth of the deepest vertex\\n    function getDeepest(TreeCtx storage _tree)\\n        external\\n        view\\n        returns (uint256, uint256)\\n    {\\n        return (_tree.deepestVertex, _tree.deepestDepth);\\n    }\\n\\n    function getRequiredDepths(uint256 _depth)\\n        private\\n        pure\\n        returns (uint256[] memory)\\n    {\\n        // parent is always included in the ancestors\\n        uint256 depth = _depth - 1;\\n        uint256 count = 1;\\n\\n        // algorithm 1\\n        // get count of trailing ones of _depth from trailing1table\\n        for (uint256 i = 0; i < 4; ) {\\n            uint256 partialCount = uint8(\\n                trailing1table[(depth >> (i * 8)) & 0xff]\\n            );\\n            count = count + partialCount;\\n            if (partialCount != 8) {\\n                break;\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // algorithm 2\\n        // get count of trailing ones by counting them\\n        // {\\n        //     while (depth & 1 > 0) {\\n        //         depth = depth >> 1;\\n        //         ++count;\\n        //     }\\n\\n        //     depth = _depth - 1;\\n        // }\\n\\n        uint256[] memory depths = new uint256[](count);\\n\\n        // construct the depths array by removing the trailing ones from lsb one by one\\n        // example _depth = b'1100 0000: b'1011 1111 -> b'1011 1110 -> b'1011 1100\\n        //                            -> b'1011 1000 -> b'1011 0000 -> b'1010 0000\\n        //                            -> b'1000 0000\\n        for (uint256 i = 0; i < count; ) {\\n            depths[i] = depth;\\n            depth = depth & (UINT32_MAX << (i + 1));\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return depths;\\n    }\\n}\\n\",\"keccak256\":\"0xe38c56f14bbe4c62101bfc5a694e4ee054b8602e93cb0aa91237701d207d362b\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x6109e261003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100875760003560e01c80636af5673e116100655780636af5673e146100ff5780636ca00e4c1461011e5780639d26337214610131578063ebcdb8721461015157600080fd5b806301b2a42d1461008c57806333fefb37146100b2578063694884b6146100c5575b600080fd5b61009f61009a366004610704565b610164565b6040519081526020015b60405180910390f35b61009f6100c0366004610726565b61017e565b6100ea6100d3366004610752565b5463ffffffff808216926401000000009092041690565b604080519283526020830191909152016100a9565b61009f61010d366004610752565b54600160401b900463ffffffff1690565b61009f61012c366004610704565b610216565b81801561013d57600080fd5b5061009f61014c366004610704565b61025c565b61009f61015f366004610726565b6103af565b60006101708383610216565b5463ffffffff169392505050565b8254600090600160401b900463ffffffff1683106101b75760405162461bcd60e51b81526004016101ae9061076b565b60405180910390fd5b60008381526001850160205260408120906101d36008856107ce565b905060006101e26008866107e2565b905060006101f18260206107f6565b600093845260019094016020525050604090205463ffffffff911c1690509392505050565b8154600090600160401b900463ffffffff1682106102465760405162461bcd60e51b81526004016101ae9061076b565b5060009081526001919091016020526040902090565b8154600090600160401b900463ffffffff168084600861027b83610815565b825463ffffffff9182166101009390930a928302919092021990911617905550600081815260018501602052604090208115610323578184106103005760405162461bcd60e51b815260206004820152601e60248201527f706172656e7420696e646578206578636565647320747265652073697a65000060448201526064016101ae565b600084815260018601602052604090205463ffffffff1661032182826104e7565b505b8054855463ffffffff918216916401000000009091041681111561037257855467ffffffffffffffff191664010000000063ffffffff8381169190910263ffffffff1916919091179084161786555b6040518581527ffe0c8c4e3d6360493265394a5a45cb3affdf2119a8b04640ea666dbd217e4f2f9060200160405180910390a15090949350505050565b8254600090600160401b900463ffffffff1683106103df5760405162461bcd60e51b81526004016101ae9061076b565b600083815260018501602052604090205463ffffffff168211156104455760405162461bcd60e51b815260206004820152601b60248201527f736561726368206465707468203e20766572746578206465707468000000000060448201526064016101ae565b825b600081815260018601602052604090205463ffffffff1683146104df5760008181526001868101602052604082208054909264010000000090910463ffffffff16918491906104969084610838565b90505b828110156104d6576104ac89838361017e565b600081815260018b01602052604090205490955063ffffffff168711156104d65760001901610499565b50505050610447565b949350505050565b60006104fc6104f783600161084f565b6105e0565b905060005b81518110156105a7576000805b60088110801561052757508351610525828561084f565b105b15610571576105378160206107f6565b84610542838661084f565b8151811061055257610552610867565b6020026020010151901b821791508061056a9061087d565b905061050e565b816001870160006105836008876107ce565b815260208101919091526040016000205561059e818461084f565b92505050610501565b6105b283600161084f565b8454925163ffffffff9081166401000000000267ffffffffffffffff19909416911617919091179092555050565b606060006105ef600184610838565b9050600160005b600481101561066b57600060405180610120016040528061010081526020016108ad61010091396106288360086107f6565b85901c60ff168151811061063e5761063e610867565b016020015160f81c9050610652818461084f565b925080600814610662575061066b565b506001016105f6565b5060008167ffffffffffffffff81111561068757610687610896565b6040519080825280602002602001820160405280156106b0578160200160208202803683370190505b50905060005b828110156106fb57838282815181106106d1576106d1610867565b60209081029190910101526106e781600161084f565b63ffffffff901b93909316926001016106b6565b50949350505050565b6000806040838503121561071757600080fd5b50508035926020909101359150565b60008060006060848603121561073b57600080fd5b505081359360208301359350604090920135919050565b60006020828403121561076457600080fd5b5035919050565b6020808252601e908201527f76657274657820696e646578206578636565647320747265652073697a650000604082015260600190565b634e487b7160e01b600052601260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b6000826107dd576107dd6107a2565b500490565b6000826107f1576107f16107a2565b500690565b6000816000190483118215151615610810576108106107b8565b500290565b600063ffffffff80831681810361082e5761082e6107b8565b6001019392505050565b60008282101561084a5761084a6107b8565b500390565b60008219821115610862576108626107b8565b500190565b634e487b7160e01b600052603260045260246000fd5b60006001820161088f5761088f6107b8565b5060010190565b634e487b7160e01b600052604160045260246000fdfe00010002000100030001000200010004000100020001000300010002000100050001000200010003000100020001000400010002000100030001000200010006000100020001000300010002000100040001000200010003000100020001000500010002000100030001000200010004000100020001000300010002000100070001000200010003000100020001000400010002000100030001000200010005000100020001000300010002000100040001000200010003000100020001000600010002000100030001000200010004000100020001000300010002000100050001000200010003000100020001000400010002000100030001000200010008a2646970667358221220b9de27882e52f3b6788811de27dccd5fe98068a6effc8ebe88ee40fee8ed6e4364736f6c634300080f0033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100875760003560e01c80636af5673e116100655780636af5673e146100ff5780636ca00e4c1461011e5780639d26337214610131578063ebcdb8721461015157600080fd5b806301b2a42d1461008c57806333fefb37146100b2578063694884b6146100c5575b600080fd5b61009f61009a366004610704565b610164565b6040519081526020015b60405180910390f35b61009f6100c0366004610726565b61017e565b6100ea6100d3366004610752565b5463ffffffff808216926401000000009092041690565b604080519283526020830191909152016100a9565b61009f61010d366004610752565b54600160401b900463ffffffff1690565b61009f61012c366004610704565b610216565b81801561013d57600080fd5b5061009f61014c366004610704565b61025c565b61009f61015f366004610726565b6103af565b60006101708383610216565b5463ffffffff169392505050565b8254600090600160401b900463ffffffff1683106101b75760405162461bcd60e51b81526004016101ae9061076b565b60405180910390fd5b60008381526001850160205260408120906101d36008856107ce565b905060006101e26008866107e2565b905060006101f18260206107f6565b600093845260019094016020525050604090205463ffffffff911c1690509392505050565b8154600090600160401b900463ffffffff1682106102465760405162461bcd60e51b81526004016101ae9061076b565b5060009081526001919091016020526040902090565b8154600090600160401b900463ffffffff168084600861027b83610815565b825463ffffffff9182166101009390930a928302919092021990911617905550600081815260018501602052604090208115610323578184106103005760405162461bcd60e51b815260206004820152601e60248201527f706172656e7420696e646578206578636565647320747265652073697a65000060448201526064016101ae565b600084815260018601602052604090205463ffffffff1661032182826104e7565b505b8054855463ffffffff918216916401000000009091041681111561037257855467ffffffffffffffff191664010000000063ffffffff8381169190910263ffffffff1916919091179084161786555b6040518581527ffe0c8c4e3d6360493265394a5a45cb3affdf2119a8b04640ea666dbd217e4f2f9060200160405180910390a15090949350505050565b8254600090600160401b900463ffffffff1683106103df5760405162461bcd60e51b81526004016101ae9061076b565b600083815260018501602052604090205463ffffffff168211156104455760405162461bcd60e51b815260206004820152601b60248201527f736561726368206465707468203e20766572746578206465707468000000000060448201526064016101ae565b825b600081815260018601602052604090205463ffffffff1683146104df5760008181526001868101602052604082208054909264010000000090910463ffffffff16918491906104969084610838565b90505b828110156104d6576104ac89838361017e565b600081815260018b01602052604090205490955063ffffffff168711156104d65760001901610499565b50505050610447565b949350505050565b60006104fc6104f783600161084f565b6105e0565b905060005b81518110156105a7576000805b60088110801561052757508351610525828561084f565b105b15610571576105378160206107f6565b84610542838661084f565b8151811061055257610552610867565b6020026020010151901b821791508061056a9061087d565b905061050e565b816001870160006105836008876107ce565b815260208101919091526040016000205561059e818461084f565b92505050610501565b6105b283600161084f565b8454925163ffffffff9081166401000000000267ffffffffffffffff19909416911617919091179092555050565b606060006105ef600184610838565b9050600160005b600481101561066b57600060405180610120016040528061010081526020016108ad61010091396106288360086107f6565b85901c60ff168151811061063e5761063e610867565b016020015160f81c9050610652818461084f565b925080600814610662575061066b565b506001016105f6565b5060008167ffffffffffffffff81111561068757610687610896565b6040519080825280602002602001820160405280156106b0578160200160208202803683370190505b50905060005b828110156106fb57838282815181106106d1576106d1610867565b60209081029190910101526106e781600161084f565b63ffffffff901b93909316926001016106b6565b50949350505050565b6000806040838503121561071757600080fd5b50508035926020909101359150565b60008060006060848603121561073b57600080fd5b505081359360208301359350604090920135919050565b60006020828403121561076457600080fd5b5035919050565b6020808252601e908201527f76657274657820696e646578206578636565647320747265652073697a650000604082015260600190565b634e487b7160e01b600052601260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b6000826107dd576107dd6107a2565b500490565b6000826107f1576107f16107a2565b500690565b6000816000190483118215151615610810576108106107b8565b500290565b600063ffffffff80831681810361082e5761082e6107b8565b6001019392505050565b60008282101561084a5761084a6107b8565b500390565b60008219821115610862576108626107b8565b500190565b634e487b7160e01b600052603260045260246000fd5b60006001820161088f5761088f6107b8565b5060010190565b634e487b7160e01b600052604160045260246000fdfe00010002000100030001000200010004000100020001000300010002000100050001000200010003000100020001000400010002000100030001000200010006000100020001000300010002000100040001000200010003000100020001000500010002000100030001000200010004000100020001000300010002000100070001000200010003000100020001000400010002000100030001000200010005000100020001000300010002000100040001000200010003000100020001000600010002000100030001000200010004000100020001000300010002000100050001000200010003000100020001000400010002000100030001000200010008a2646970667358221220b9de27882e52f3b6788811de27dccd5fe98068a6effc8ebe88ee40fee8ed6e4364736f6c634300080f0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "getAncestor(Tree.TreeCtx storage,uint256,uint256)": {
        "params": {
          "_ancestorOffset": "the offset of the ancestor in ancestor map",
          "_tree": "pointer to the tree storage",
          "_vertex": "the index of the vertex in the vertices map (tree)"
        },
        "returns": {
          "_0": "index of ancestor vertex in the tree"
        }
      },
      "getAncestorAtDepth(Tree.TreeCtx storage,uint256,uint256)": {
        "params": {
          "_depth": "the depth of the ancestor",
          "_tree": "pointer to the tree storage",
          "_vertex": "the index of the vertex in the vertices map (tree)"
        },
        "returns": {
          "_0": "index of ancestor at depth of _vertex"
        }
      },
      "getDeepest(Tree.TreeCtx storage)": {
        "params": {
          "_tree": "pointer to the tree storage"
        },
        "returns": {
          "_0": "index number and depth of the deepest vertex"
        }
      },
      "getDepth(Tree.TreeCtx storage,uint256)": {
        "params": {
          "_tree": "pointer to the tree storage",
          "_vertex": "the index of the vertex in the vertices map (tree)"
        }
      },
      "getTreeSize(Tree.TreeCtx storage)": {
        "params": {
          "_tree": "pointer to the tree storage"
        }
      },
      "getVertex(Tree.TreeCtx storage,uint256)": {
        "params": {
          "_tree": "pointer to the tree storage",
          "_vertex": "the index of the vertex in the vertices map (tree)"
        }
      },
      "insertVertex(Tree.TreeCtx storage,uint256)": {
        "details": "the tree can hold up to UINT32_MAX vertices, if the insertVertex is called when tree is full, the transaction will be reverted",
        "params": {
          "_parent": "the index of parent vertex in the vertices map (tree)",
          "_tree": "pointer to the tree storage"
        },
        "returns": {
          "_0": "index of the inserted vertex"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getAncestor(Tree.TreeCtx storage,uint256,uint256)": {
        "notice": "Get an ancestor of a vertex in the tree with a certain ancestor offset"
      },
      "getAncestorAtDepth(Tree.TreeCtx storage,uint256,uint256)": {
        "notice": "Search an ancestor of a vertex in the tree at a certain depth"
      },
      "getDeepest(Tree.TreeCtx storage)": {
        "notice": "Get current tree size"
      },
      "getDepth(Tree.TreeCtx storage,uint256)": {
        "notice": "Get depth of vertex"
      },
      "getTreeSize(Tree.TreeCtx storage)": {
        "notice": "Get current tree size"
      },
      "getVertex(Tree.TreeCtx storage,uint256)": {
        "notice": "Get vertex from the tree"
      },
      "insertVertex(Tree.TreeCtx storage,uint256)": {
        "notice": "Insert a vertex to the tree"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}