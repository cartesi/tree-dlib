{
  "address": "0x001990D73898A115d4F5D3F750F9003E49E9FDFD",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_parent",
          "type": "uint256"
        }
      ],
      "name": "VertexInserted",
      "type": "event"
    }
  ],
  "transactionHash": "0x006c4a8513ea6c6df52992cbca96af109cf5995b848cca564d0ff67ef327c34d",
  "receipt": {
    "to": null,
    "from": "0x18930e8a66a1DbE21D00581216789AAB7460Afd0",
    "contractAddress": "0x001990D73898A115d4F5D3F750F9003E49E9FDFD",
    "transactionIndex": 3,
    "gasUsed": "618251",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xd28aa3a63429fe2be2fa0e9eac671f84aba8caedc49acc789c1df5eb9a0506be",
    "transactionHash": "0x006c4a8513ea6c6df52992cbca96af109cf5995b848cca564d0ff67ef327c34d",
    "logs": [],
    "blockNumber": 21256742,
    "cumulativeGasUsed": "1329334",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 5,
  "solcInputHash": "0592a3b35de232461b7b2752e3e9d380",
  "metadata": "{\"compiler\":{\"version\":\"0.8.15+commit.e14f2714\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_parent\",\"type\":\"uint256\"}],\"name\":\"VertexInserted\",\"type\":\"event\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getAncestor(Tree.TreeCtx storage,uint256,uint256)\":{\"params\":{\"_ancestorOffset\":\"the offset of the ancestor in ancestor cache\",\"_tree\":\"pointer to the tree storage\",\"_vertex\":\"the index of the vertex in the vertices map (tree)\"},\"returns\":{\"_0\":\"index of ancestor vertex in the tree\"}},\"getAncestorAtDepth(Tree.TreeCtx storage,uint256,uint256)\":{\"params\":{\"_depth\":\"the depth of the ancestor\",\"_tree\":\"pointer to the tree storage\",\"_vertex\":\"the index of the vertex in the vertices map (tree)\"},\"returns\":{\"_0\":\"index of ancestor at depth of _vertex\"}},\"getDeepest(Tree.TreeCtx storage)\":{\"params\":{\"_tree\":\"pointer to the tree storage\"},\"returns\":{\"_0\":\"index number and depth of the deepest vertex\"}},\"getDepth(Tree.TreeCtx storage,uint256)\":{\"params\":{\"_tree\":\"pointer to the tree storage\",\"_vertex\":\"the index of the vertex in the vertices map (tree)\"}},\"getTreeSize(Tree.TreeCtx storage)\":{\"params\":{\"_tree\":\"pointer to the tree storage\"}},\"getVertex(Tree.TreeCtx storage,uint256)\":{\"params\":{\"_tree\":\"pointer to the tree storage\",\"_vertex\":\"the index of the vertex in the vertices map (tree)\"}},\"insertVertex(Tree.TreeCtx storage,uint256)\":{\"details\":\"the tree can hold up to UINT32_MAX vertices, if the insertVertex is called when tree is full, the transaction will be reverted\",\"params\":{\"_parent\":\"the index of parent vertex in the vertices map (tree)\",\"_tree\":\"pointer to the tree storage\"},\"returns\":{\"_0\":\"index of the inserted vertex\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getAncestor(Tree.TreeCtx storage,uint256,uint256)\":{\"notice\":\"Get an ancestor of a vertex from its ancestor cache by offset\"},\"getAncestorAtDepth(Tree.TreeCtx storage,uint256,uint256)\":{\"notice\":\"Search an ancestor of a vertex in the tree at a certain depth\"},\"getDeepest(Tree.TreeCtx storage)\":{\"notice\":\"Get current tree size\"},\"getDepth(Tree.TreeCtx storage,uint256)\":{\"notice\":\"Get depth of vertex\"},\"getTreeSize(Tree.TreeCtx storage)\":{\"notice\":\"Get current tree size\"},\"getVertex(Tree.TreeCtx storage,uint256)\":{\"notice\":\"Get vertex from the tree\"},\"insertVertex(Tree.TreeCtx storage,uint256)\":{\"notice\":\"Insert a vertex to the tree\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Tree.sol\":\"Tree\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/Tree.sol\":{\"content\":\"// Copyright 2022 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Tree Library\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Tree {\\n    // The tree can store up to UINT32_MAX vertices, the type uses uint256 for gas optimization purpose.\\n    // It's the library caller's responsibility to check the input arguments are within the proper range\\n    uint256 constant UINT32_MAX = 2**32 - 1;\\n    // count of trailing ones for [0:256)\\n    // each number takes one byte\\n    bytes constant trailing1table =\\n        hex\\\"00010002000100030001000200010004000100020001000300010002000100050001000200010003000100020001000400010002000100030001000200010006000100020001000300010002000100040001000200010003000100020001000500010002000100030001000200010004000100020001000300010002000100070001000200010003000100020001000400010002000100030001000200010005000100020001000300010002000100040001000200010003000100020001000600010002000100030001000200010004000100020001000300010002000100050001000200010003000100020001000400010002000100030001000200010008\\\";\\n\\n    struct TreeCtx {\\n        uint32 deepestVertex;\\n        uint32 deepestDepth;\\n        uint32 verticesLength;\\n        mapping(uint256 => Vertex) vertices;\\n    }\\n\\n    struct Vertex {\\n        uint32 depth; // depth of the vertex in the tree\\n        uint32 ancestorsLength;\\n        // Each uint256 value stores 8 ancestors, each takes a uint32 slot,\\n        // the key used to access the value should be preprocessed,\\n        // 0 => uint32[7],uint32[6],uint32[5],uint32[4],uint32[3],uint32[2],uint32[1],uint32[0]\\n        // 1 => uint32[15],uint32[14],uint32[13],uint32[12],uint32[11],uint32[10],uint32[9],uint32[8]\\n        // A vertex can have up to 32 ancestors\\n        mapping(uint256 => uint256) ancestors; // pointers to ancestors' indices in the vertices map (tree)\\n    }\\n\\n    event VertexInserted(uint256 _parent);\\n\\n    /// @notice Insert a vertex to the tree\\n    /// @param _tree pointer to the tree storage\\n    /// @param _parent the index of parent vertex in the vertices map (tree)\\n    /// @return index of the inserted vertex\\n    /// @dev the tree can hold up to UINT32_MAX vertices, if the insertVertex is called when tree is full, the transaction will be reverted\\n    function insertVertex(TreeCtx storage _tree, uint256 _parent)\\n        external\\n        returns (uint256)\\n    {\\n        uint256 treeSize = _tree.verticesLength;\\n\\n        _tree.verticesLength++;\\n        Vertex storage v = _tree.vertices[treeSize];\\n\\n        if (treeSize == 0) {\\n            // insert the very first vertex into the tree\\n            // v is initialized with zeros already\\n        } else {\\n            // insert vertex to the tree attaching to another vertex\\n            require(_parent < treeSize, \\\"parent index exceeds tree size\\\");\\n\\n            uint256 parentDepth = _tree.vertices[_parent].depth;\\n\\n            // construct the ancestors map in batch\\n            batchSetAncestors(v, parentDepth);\\n        }\\n\\n        uint256 depth = v.depth;\\n        if (depth > _tree.deepestDepth) {\\n            _tree.deepestDepth = uint32(depth);\\n            _tree.deepestVertex = uint32(treeSize);\\n        }\\n\\n        emit VertexInserted(_parent);\\n\\n        return treeSize;\\n    }\\n\\n    /// @notice Set ancestors in batches, each of which has up to 8 ancestors\\n    /// @param _v pointer to the vertex storage\\n    /// @param _parentDepth the parent depth\\n    function batchSetAncestors(Vertex storage _v, uint256 _parentDepth)\\n        private\\n    {\\n        // calculate all ancestors' depths of the new vertex\\n        uint256[] memory requiredDepths = getRequiredDepths(_parentDepth + 1);\\n        uint256 batchPointer; // point to the beginning of a batch\\n\\n        while (batchPointer < requiredDepths.length) {\\n            uint256 ancestorsBatch; // stores up to 8 ancestors\\n            uint256 offset; // 0~8\\n            while (\\n                offset < 8 && batchPointer + offset < requiredDepths.length\\n            ) {\\n                ancestorsBatch =\\n                    ancestorsBatch |\\n                    (requiredDepths[batchPointer + offset] << (offset * 32));\\n\\n                ++offset;\\n            }\\n            _v.ancestors[batchPointer / 8] = ancestorsBatch;\\n\\n            batchPointer += offset;\\n        }\\n\\n        _v.depth = uint32(_parentDepth + 1);\\n        _v.ancestorsLength = uint32(requiredDepths.length);\\n    }\\n\\n    /// @notice Get an ancestor of a vertex from its ancestor cache by offset\\n    /// @param _tree pointer to the tree storage\\n    /// @param _vertex the index of the vertex in the vertices map (tree)\\n    /// @param _ancestorOffset the offset of the ancestor in ancestor cache\\n    /// @return index of ancestor vertex in the tree\\n    function getAncestor(\\n        TreeCtx storage _tree,\\n        uint256 _vertex,\\n        uint256 _ancestorOffset\\n    ) public view returns (uint256) {\\n        require(\\n            _vertex < _tree.verticesLength,\\n            \\\"vertex index exceeds tree size\\\"\\n        );\\n\\n        Vertex storage v = _tree.vertices[_vertex];\\n\\n        require(_ancestorOffset < v.ancestorsLength, \\\"offset exceeds cache size\\\");\\n\\n        uint256 key = _ancestorOffset / 8;\\n        uint256 offset = _ancestorOffset % 8;\\n        uint256 ancestor = (v.ancestors[key] >> (offset * 32)) & 0xffffffff;\\n\\n        return ancestor;\\n    }\\n\\n    /// @notice Search an ancestor of a vertex in the tree at a certain depth\\n    /// @param _tree pointer to the tree storage\\n    /// @param _vertex the index of the vertex in the vertices map (tree)\\n    /// @param _depth the depth of the ancestor\\n    /// @return index of ancestor at depth of _vertex\\n    function getAncestorAtDepth(\\n        TreeCtx storage _tree,\\n        uint256 _vertex,\\n        uint256 _depth\\n    ) external view returns (uint256) {\\n        require(\\n            _vertex < _tree.verticesLength,\\n            \\\"vertex index exceeds tree size\\\"\\n        );\\n        require(\\n            _depth <= _tree.vertices[_vertex].depth,\\n            \\\"search depth > vertex depth\\\"\\n        );\\n\\n        uint256 vertex = _vertex;\\n\\n        while (_depth != _tree.vertices[vertex].depth) {\\n            Vertex storage v = _tree.vertices[vertex];\\n            uint256 ancestorsLength = v.ancestorsLength;\\n            // start searching from the oldest ancestor (smallest depth)\\n            // example: search ancestor at depth d(20, b'0001 0100) from vertex v at depth (176, b'1011 0000)\\n            //    b'1011 0000 -> b'1010 0000 -> b'1000 0000\\n            // -> b'0100 0000 -> b'0010 0000 -> b'0001 1000\\n            // -> b'0001 0100\\n\\n            // given that ancestorsOffset is unsigned, when -1 at 0, it'll underflow and become UINT32_MAX\\n            // so the continue condition has to be ancestorsOffset < ancestorsLength,\\n            // can't be ancestorsOffset >= 0\\n            uint256 temp_v = vertex;\\n            for (\\n                uint256 ancestorsOffset = ancestorsLength - 1;\\n                ancestorsOffset < ancestorsLength;\\n\\n            ) {\\n                vertex = getAncestor(_tree, temp_v, ancestorsOffset);\\n\\n                // stop at the ancestor who's closest to the target depth\\n                if (_tree.vertices[vertex].depth >= _depth) {\\n                    break;\\n                }\\n\\n                unchecked {\\n                    --ancestorsOffset;\\n                }\\n            }\\n        }\\n\\n        return vertex;\\n    }\\n\\n    /// @notice Get depth of vertex\\n    /// @param _tree pointer to the tree storage\\n    /// @param _vertex the index of the vertex in the vertices map (tree)\\n    function getDepth(TreeCtx storage _tree, uint256 _vertex)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return getVertex(_tree, _vertex).depth;\\n    }\\n\\n    /// @notice Get vertex from the tree\\n    /// @param _tree pointer to the tree storage\\n    /// @param _vertex the index of the vertex in the vertices map (tree)\\n    function getVertex(TreeCtx storage _tree, uint256 _vertex)\\n        public\\n        view\\n        returns (Vertex storage)\\n    {\\n        require(\\n            _vertex < _tree.verticesLength,\\n            \\\"vertex index exceeds tree size\\\"\\n        );\\n\\n        return _tree.vertices[_vertex];\\n    }\\n\\n    /// @notice Get current tree size\\n    /// @param _tree pointer to the tree storage\\n    function getTreeSize(TreeCtx storage _tree)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return _tree.verticesLength;\\n    }\\n\\n    /// @notice Get current tree size\\n    /// @param _tree pointer to the tree storage\\n    /// @return index number and depth of the deepest vertex\\n    function getDeepest(TreeCtx storage _tree)\\n        external\\n        view\\n        returns (uint256, uint256)\\n    {\\n        return (_tree.deepestVertex, _tree.deepestDepth);\\n    }\\n\\n    function getRequiredDepths(uint256 _depth)\\n        private\\n        pure\\n        returns (uint256[] memory)\\n    {\\n        // parent is always included in the ancestors\\n        uint256 depth = _depth - 1;\\n        uint256 count = 1;\\n\\n        // algorithm 1\\n        // get count of trailing ones of _depth from trailing1table\\n        for (uint256 i = 0; i < 4; ) {\\n            uint256 partialCount = uint8(\\n                trailing1table[(depth >> (i * 8)) & 0xff]\\n            );\\n            count = count + partialCount;\\n            if (partialCount != 8) {\\n                break;\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // algorithm 2\\n        // get count of trailing ones by counting them\\n        // {\\n        //     while (depth & 1 > 0) {\\n        //         depth = depth >> 1;\\n        //         ++count;\\n        //     }\\n\\n        //     depth = _depth - 1;\\n        // }\\n\\n        uint256[] memory depths = new uint256[](count);\\n\\n        // construct the depths array by removing the trailing ones from lsb one by one\\n        // example _depth = b'1100 0000: b'1011 1111 -> b'1011 1110 -> b'1011 1100\\n        //                            -> b'1011 1000 -> b'1011 0000 -> b'1010 0000\\n        //                            -> b'1000 0000\\n        for (uint256 i = 0; i < count; ) {\\n            depths[i] = depth;\\n            depth = depth & (UINT32_MAX << (i + 1));\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return depths;\\n    }\\n}\\n\",\"keccak256\":\"0xf9f21db397a96d1b093e20972e5ec4f3777997b30c0e47ec688d2378465b2be7\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x610a4161003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100875760003560e01c80636af5673e116100655780636af5673e146100ff5780636ca00e4c1461011e5780639d26337214610131578063ebcdb8721461015157600080fd5b806301b2a42d1461008c57806333fefb37146100b2578063694884b6146100c5575b600080fd5b61009f61009a366004610763565b610164565b6040519081526020015b60405180910390f35b61009f6100c0366004610785565b61017e565b6100ea6100d33660046107b1565b5463ffffffff808216926401000000009092041690565b604080519283526020830191909152016100a9565b61009f61010d3660046107b1565b54600160401b900463ffffffff1690565b61009f61012c366004610763565b610275565b81801561013d57600080fd5b5061009f61014c366004610763565b6102bb565b61009f61015f366004610785565b61040e565b60006101708383610275565b5463ffffffff169392505050565b8254600090600160401b900463ffffffff1683106101b75760405162461bcd60e51b81526004016101ae906107ca565b60405180910390fd5b600083815260018501602052604090208054640100000000900463ffffffff1683106102255760405162461bcd60e51b815260206004820152601960248201527f6f666673657420657863656564732063616368652073697a650000000000000060448201526064016101ae565b600061023260088561082d565b90506000610241600886610841565b90506000610250826020610855565b600093845260019094016020525050604090205463ffffffff911c1690509392505050565b8154600090600160401b900463ffffffff1682106102a55760405162461bcd60e51b81526004016101ae906107ca565b5060009081526001919091016020526040902090565b8154600090600160401b900463ffffffff16808460086102da83610874565b825463ffffffff9182166101009390930a9283029190920219909116179055506000818152600185016020526040902081156103825781841061035f5760405162461bcd60e51b815260206004820152601e60248201527f706172656e7420696e646578206578636565647320747265652073697a65000060448201526064016101ae565b600084815260018601602052604090205463ffffffff166103808282610546565b505b8054855463ffffffff91821691640100000000909104168111156103d157855467ffffffffffffffff191664010000000063ffffffff8381169190910263ffffffff1916919091179084161786555b6040518581527ffe0c8c4e3d6360493265394a5a45cb3affdf2119a8b04640ea666dbd217e4f2f9060200160405180910390a15090949350505050565b8254600090600160401b900463ffffffff16831061043e5760405162461bcd60e51b81526004016101ae906107ca565b600083815260018501602052604090205463ffffffff168211156104a45760405162461bcd60e51b815260206004820152601b60248201527f736561726368206465707468203e20766572746578206465707468000000000060448201526064016101ae565b825b600081815260018601602052604090205463ffffffff16831461053e5760008181526001868101602052604082208054909264010000000090910463ffffffff16918491906104f59084610897565b90505b828110156105355761050b89838361017e565b600081815260018b01602052604090205490955063ffffffff1687111561053557600019016104f8565b505050506104a6565b949350505050565b600061055b6105568360016108ae565b61063f565b905060005b8151811015610606576000805b6008811080156105865750835161058482856108ae565b105b156105d057610596816020610855565b846105a183866108ae565b815181106105b1576105b16108c6565b6020026020010151901b82179150806105c9906108dc565b905061056d565b816001870160006105e260088761082d565b81526020810191909152604001600020556105fd81846108ae565b92505050610560565b6106118360016108ae565b8454925163ffffffff9081166401000000000267ffffffffffffffff19909416911617919091179092555050565b6060600061064e600184610897565b9050600160005b60048110156106ca576000604051806101200160405280610100815260200161090c6101009139610687836008610855565b85901c60ff168151811061069d5761069d6108c6565b016020015160f81c90506106b181846108ae565b9250806008146106c157506106ca565b50600101610655565b5060008167ffffffffffffffff8111156106e6576106e66108f5565b60405190808252806020026020018201604052801561070f578160200160208202803683370190505b50905060005b8281101561075a5783828281518110610730576107306108c6565b60209081029190910101526107468160016108ae565b63ffffffff901b9390931692600101610715565b50949350505050565b6000806040838503121561077657600080fd5b50508035926020909101359150565b60008060006060848603121561079a57600080fd5b505081359360208301359350604090920135919050565b6000602082840312156107c357600080fd5b5035919050565b6020808252601e908201527f76657274657820696e646578206578636565647320747265652073697a650000604082015260600190565b634e487b7160e01b600052601260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b60008261083c5761083c610801565b500490565b60008261085057610850610801565b500690565b600081600019048311821515161561086f5761086f610817565b500290565b600063ffffffff80831681810361088d5761088d610817565b6001019392505050565b6000828210156108a9576108a9610817565b500390565b600082198211156108c1576108c1610817565b500190565b634e487b7160e01b600052603260045260246000fd5b6000600182016108ee576108ee610817565b5060010190565b634e487b7160e01b600052604160045260246000fdfe00010002000100030001000200010004000100020001000300010002000100050001000200010003000100020001000400010002000100030001000200010006000100020001000300010002000100040001000200010003000100020001000500010002000100030001000200010004000100020001000300010002000100070001000200010003000100020001000400010002000100030001000200010005000100020001000300010002000100040001000200010003000100020001000600010002000100030001000200010004000100020001000300010002000100050001000200010003000100020001000400010002000100030001000200010008a264697066735822122064c0ca966685be369d85c82cdf4168a5d171e6fc389161d17a4aac0419caa25c64736f6c634300080f0033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100875760003560e01c80636af5673e116100655780636af5673e146100ff5780636ca00e4c1461011e5780639d26337214610131578063ebcdb8721461015157600080fd5b806301b2a42d1461008c57806333fefb37146100b2578063694884b6146100c5575b600080fd5b61009f61009a366004610763565b610164565b6040519081526020015b60405180910390f35b61009f6100c0366004610785565b61017e565b6100ea6100d33660046107b1565b5463ffffffff808216926401000000009092041690565b604080519283526020830191909152016100a9565b61009f61010d3660046107b1565b54600160401b900463ffffffff1690565b61009f61012c366004610763565b610275565b81801561013d57600080fd5b5061009f61014c366004610763565b6102bb565b61009f61015f366004610785565b61040e565b60006101708383610275565b5463ffffffff169392505050565b8254600090600160401b900463ffffffff1683106101b75760405162461bcd60e51b81526004016101ae906107ca565b60405180910390fd5b600083815260018501602052604090208054640100000000900463ffffffff1683106102255760405162461bcd60e51b815260206004820152601960248201527f6f666673657420657863656564732063616368652073697a650000000000000060448201526064016101ae565b600061023260088561082d565b90506000610241600886610841565b90506000610250826020610855565b600093845260019094016020525050604090205463ffffffff911c1690509392505050565b8154600090600160401b900463ffffffff1682106102a55760405162461bcd60e51b81526004016101ae906107ca565b5060009081526001919091016020526040902090565b8154600090600160401b900463ffffffff16808460086102da83610874565b825463ffffffff9182166101009390930a9283029190920219909116179055506000818152600185016020526040902081156103825781841061035f5760405162461bcd60e51b815260206004820152601e60248201527f706172656e7420696e646578206578636565647320747265652073697a65000060448201526064016101ae565b600084815260018601602052604090205463ffffffff166103808282610546565b505b8054855463ffffffff91821691640100000000909104168111156103d157855467ffffffffffffffff191664010000000063ffffffff8381169190910263ffffffff1916919091179084161786555b6040518581527ffe0c8c4e3d6360493265394a5a45cb3affdf2119a8b04640ea666dbd217e4f2f9060200160405180910390a15090949350505050565b8254600090600160401b900463ffffffff16831061043e5760405162461bcd60e51b81526004016101ae906107ca565b600083815260018501602052604090205463ffffffff168211156104a45760405162461bcd60e51b815260206004820152601b60248201527f736561726368206465707468203e20766572746578206465707468000000000060448201526064016101ae565b825b600081815260018601602052604090205463ffffffff16831461053e5760008181526001868101602052604082208054909264010000000090910463ffffffff16918491906104f59084610897565b90505b828110156105355761050b89838361017e565b600081815260018b01602052604090205490955063ffffffff1687111561053557600019016104f8565b505050506104a6565b949350505050565b600061055b6105568360016108ae565b61063f565b905060005b8151811015610606576000805b6008811080156105865750835161058482856108ae565b105b156105d057610596816020610855565b846105a183866108ae565b815181106105b1576105b16108c6565b6020026020010151901b82179150806105c9906108dc565b905061056d565b816001870160006105e260088761082d565b81526020810191909152604001600020556105fd81846108ae565b92505050610560565b6106118360016108ae565b8454925163ffffffff9081166401000000000267ffffffffffffffff19909416911617919091179092555050565b6060600061064e600184610897565b9050600160005b60048110156106ca576000604051806101200160405280610100815260200161090c6101009139610687836008610855565b85901c60ff168151811061069d5761069d6108c6565b016020015160f81c90506106b181846108ae565b9250806008146106c157506106ca565b50600101610655565b5060008167ffffffffffffffff8111156106e6576106e66108f5565b60405190808252806020026020018201604052801561070f578160200160208202803683370190505b50905060005b8281101561075a5783828281518110610730576107306108c6565b60209081029190910101526107468160016108ae565b63ffffffff901b9390931692600101610715565b50949350505050565b6000806040838503121561077657600080fd5b50508035926020909101359150565b60008060006060848603121561079a57600080fd5b505081359360208301359350604090920135919050565b6000602082840312156107c357600080fd5b5035919050565b6020808252601e908201527f76657274657820696e646578206578636565647320747265652073697a650000604082015260600190565b634e487b7160e01b600052601260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b60008261083c5761083c610801565b500490565b60008261085057610850610801565b500690565b600081600019048311821515161561086f5761086f610817565b500290565b600063ffffffff80831681810361088d5761088d610817565b6001019392505050565b6000828210156108a9576108a9610817565b500390565b600082198211156108c1576108c1610817565b500190565b634e487b7160e01b600052603260045260246000fd5b6000600182016108ee576108ee610817565b5060010190565b634e487b7160e01b600052604160045260246000fdfe00010002000100030001000200010004000100020001000300010002000100050001000200010003000100020001000400010002000100030001000200010006000100020001000300010002000100040001000200010003000100020001000500010002000100030001000200010004000100020001000300010002000100070001000200010003000100020001000400010002000100030001000200010005000100020001000300010002000100040001000200010003000100020001000600010002000100030001000200010004000100020001000300010002000100050001000200010003000100020001000400010002000100030001000200010008a264697066735822122064c0ca966685be369d85c82cdf4168a5d171e6fc389161d17a4aac0419caa25c64736f6c634300080f0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "getAncestor(Tree.TreeCtx storage,uint256,uint256)": {
        "params": {
          "_ancestorOffset": "the offset of the ancestor in ancestor cache",
          "_tree": "pointer to the tree storage",
          "_vertex": "the index of the vertex in the vertices map (tree)"
        },
        "returns": {
          "_0": "index of ancestor vertex in the tree"
        }
      },
      "getAncestorAtDepth(Tree.TreeCtx storage,uint256,uint256)": {
        "params": {
          "_depth": "the depth of the ancestor",
          "_tree": "pointer to the tree storage",
          "_vertex": "the index of the vertex in the vertices map (tree)"
        },
        "returns": {
          "_0": "index of ancestor at depth of _vertex"
        }
      },
      "getDeepest(Tree.TreeCtx storage)": {
        "params": {
          "_tree": "pointer to the tree storage"
        },
        "returns": {
          "_0": "index number and depth of the deepest vertex"
        }
      },
      "getDepth(Tree.TreeCtx storage,uint256)": {
        "params": {
          "_tree": "pointer to the tree storage",
          "_vertex": "the index of the vertex in the vertices map (tree)"
        }
      },
      "getTreeSize(Tree.TreeCtx storage)": {
        "params": {
          "_tree": "pointer to the tree storage"
        }
      },
      "getVertex(Tree.TreeCtx storage,uint256)": {
        "params": {
          "_tree": "pointer to the tree storage",
          "_vertex": "the index of the vertex in the vertices map (tree)"
        }
      },
      "insertVertex(Tree.TreeCtx storage,uint256)": {
        "details": "the tree can hold up to UINT32_MAX vertices, if the insertVertex is called when tree is full, the transaction will be reverted",
        "params": {
          "_parent": "the index of parent vertex in the vertices map (tree)",
          "_tree": "pointer to the tree storage"
        },
        "returns": {
          "_0": "index of the inserted vertex"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getAncestor(Tree.TreeCtx storage,uint256,uint256)": {
        "notice": "Get an ancestor of a vertex from its ancestor cache by offset"
      },
      "getAncestorAtDepth(Tree.TreeCtx storage,uint256,uint256)": {
        "notice": "Search an ancestor of a vertex in the tree at a certain depth"
      },
      "getDeepest(Tree.TreeCtx storage)": {
        "notice": "Get current tree size"
      },
      "getDepth(Tree.TreeCtx storage,uint256)": {
        "notice": "Get depth of vertex"
      },
      "getTreeSize(Tree.TreeCtx storage)": {
        "notice": "Get current tree size"
      },
      "getVertex(Tree.TreeCtx storage,uint256)": {
        "notice": "Get vertex from the tree"
      },
      "insertVertex(Tree.TreeCtx storage,uint256)": {
        "notice": "Insert a vertex to the tree"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}